// test/modelVerification.js
// Verificaci√≥n simple de archivos de modelo TensorFlow.js

const fs = require('fs');
const path = require('path');

function verifyModelFiles() {
  console.log('üß™ Verificando archivos de modelo TensorFlow.js...\n');
  
  // Directorio del modelo
  const modelDir = path.join(__dirname, '../assets/Modelo/tfjs_model');
  
  // Archivos esperados
  const expectedFiles = [
    'model.json',
    'group1-shard1of3.bin',
    'group1-shard2of3.bin', 
    'group1-shard3of3.bin'
  ];
  
  let allFilesValid = true;
  
  // Verificar que el directorio existe
  if (!fs.existsSync(modelDir)) {
    console.error(`‚ùå Directorio de modelo no existe: ${modelDir}`);
    return false;
  }
  
  console.log(`üìÅ Directorio de modelo: ${modelDir}`);
  
  // Verificar cada archivo
  expectedFiles.forEach(fileName => {
    const filePath = path.join(modelDir, fileName);
    
    if (fs.existsSync(filePath)) {
      const stats = fs.statSync(filePath);
      const sizeKB = Math.round(stats.size / 1024);
      console.log(`‚úÖ ${fileName} - ${sizeKB} KB`);
    } else {
      console.error(`‚ùå ${fileName} - NO ENCONTRADO`);
      allFilesValid = false;
    }
  });
  
  console.log('\nüìä Verificando contenido de model.json...');
  
  try {
    const modelJsonPath = path.join(modelDir, 'model.json');
    const modelJson = JSON.parse(fs.readFileSync(modelJsonPath, 'utf8'));
    
    console.log('üìã Informaci√≥n del modelo:');
    console.log(`   - Format: ${modelJson.format || 'no especificado'}`);
    console.log(`   - Generated by: ${modelJson.generatedBy || 'no especificado'}`);
    console.log(`   - Model topology definido: ${!!modelJson.modelTopology}`);
    console.log(`   - Weights manifest: ${modelJson.weightsManifest ? modelJson.weightsManifest.length + ' entradas' : 'no definido'}`);
    
    if (modelJson.weightsManifest) {
      console.log('üì¶ Archivos de pesos referenciados:');
      modelJson.weightsManifest.forEach((manifest, index) => {
        if (manifest.paths) {
          manifest.paths.forEach(pathName => {
            console.log(`   - ${pathName}`);
          });
        }
      });
    }
    
  } catch (error) {
    console.error('‚ùå Error leyendo model.json:', error.message);
    allFilesValid = false;
  }
  
  console.log('\nüéØ Resultado de verificaci√≥n:');
  if (allFilesValid) {
    console.log('‚úÖ Todos los archivos de modelo est√°n presentes y v√°lidos');
    console.log('üöÄ El modelo deber√≠a poder cargarse en TensorFlow.js');
  } else {
    console.log('‚ùå Faltan archivos o hay errores en el modelo');
    console.log('üîß Es necesario regenerar los archivos del modelo');
  }
  
  return allFilesValid;
}

// Funci√≥n adicional para verificar el modelo YOLOv8 original
function verifyOriginalModel() {
  console.log('\nüîç Verificando modelo YOLOv8 original...');
  
  const originalModelPath = path.join(__dirname, '../assets/Modelo/yolov8n.pt');
  const savedModelPath = path.join(__dirname, '../assets/Modelo/runs/detect/train/weights/best_saved_model');
  
  if (fs.existsSync(originalModelPath)) {
    const stats = fs.statSync(originalModelPath);
    const sizeMB = Math.round(stats.size / (1024 * 1024));
    console.log(`‚úÖ Modelo PyTorch original: yolov8n.pt - ${sizeMB} MB`);
  } else {
    console.log('‚ùå Modelo PyTorch original no encontrado');
  }
  
  if (fs.existsSync(savedModelPath)) {
    console.log('‚úÖ SavedModel disponible para conversi√≥n');
  } else {
    console.log('‚ùå SavedModel no disponible');
  }
}

// Ejecutar verificaciones
if (require.main === module) {
  console.log('üî¨ Verificaci√≥n de Modelo TensorFlow.js');
  console.log('=====================================');
  
  const isValid = verifyModelFiles();
  verifyOriginalModel();
  
  console.log('\nüìÑ Resumen final:');
  console.log(`Estado del modelo: ${isValid ? '‚úÖ V√ÅLIDO' : '‚ùå INV√ÅLIDO'}`);
  
  process.exit(isValid ? 0 : 1);
}

module.exports = { verifyModelFiles, verifyOriginalModel };